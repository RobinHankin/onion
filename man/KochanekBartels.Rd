% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/KochanekBartels.R
\encoding{UTF-8}
\name{KochanekBartels}
\alias{KochanekBartels}
\title{Kochanek-Bartels quaternions spline}
\usage{
KochanekBartels(
  keyRotors,
  keyTimes = NULL,
  tcb = c(0, 0, 0),
  times,
  n_intertimes,
  endcondition = "natural",
  constantSpeed = FALSE
)
}
\arguments{
\item{keyRotors}{a vector of unit quaternions (rotors) to be interpolated}

\item{keyTimes}{the times corresponding to the key rotors; must be an
increasing vector of the same length a \code{keyRotors} if
\code{endcondition = "natural"} or of length one more than number of key
rotors if \code{endcondition = "closed"}}

\item{tcb}{a vector of three numbers respectively corresponding to tension,
continuity and bias}

\item{times}{the times of interpolation; each time must lie within the range
of the key times; this parameter can be missing if \code{keyTimes} is
\code{NULL} and \code{n_intertimes} is not missing, and it is ignored if
\code{constantSpeed=TRUE}}

\item{n_intertimes}{should be missing if \code{times} is given; otherwise,
\code{keyTimes} should be \code{NULL} and \code{times} is constructed by
linearly interpolating the automatic key times such that there are
\code{n_intertimes - 1} between two key times (so the times are the key
times if \code{n_intertimes = 1}); if you don't want to use the automatic
key times (\code{keyTimes=NULL}), you can perform such an interpolation
with the function \code{\link{interpolateTimes}}}

\item{endcondition}{start/end conditions, can be \code{"closed"} or
\code{"natural"}}

\item{constantSpeed}{Boolean, whether to re-parameterize the spline to
have constant speed; in this case, \code{"times"} is ignored and a
function is returned, with an attribute \code{"times"}, the vector of
new times corresponding to the key rotors}
}
\value{
A vector of quaternions having the same length as the \code{times}
  vector, or a (slow) function if \code{constantSpeed=TRUE}.
}
\description{
Constructs a quaternions spline by the Kochanek-Bartels
  algorithm.
}
\examples{
library(onion)
# We will use a Kochanek-Bartels quaternions spline to construct a spherical
#   curve interpolating some key points on the sphere of radius 5

# helper function: spherical to Cartesian coordinates
sph2cart <- function(rho, theta, phi){
  c(
    rho * cos(theta) * sin(phi),
    rho * sin(theta) * sin(phi),
    rho * cos(phi)
  )
}

# construction of the key points on the sphere
keyPoints <- matrix(nrow = 0L, ncol = 3L)
theta_ <- seq(0, 2*pi, length.out = 9L)[-1L]
phi <- 1.3
for(theta in theta_){
  keyPoints <- rbind(keyPoints, sph2cart(5, theta, phi))
  phi <- pi - phi
}
n_keyPoints <- nrow(keyPoints)

# construction of the key rotors; the first key rotor is the identity
#   quaternion and rotor i sends the key point i-1 to the key point i
keyRotors <- quaternion(length.out = n_keyPoints)
rotor <- keyRotors[1L] <- H1
for(i in seq_len(n_keyPoints - 1L)){
  keyRotors[i+1L] <- rotor <-
    quaternionFromTo(keyPoints[i, ]/5, keyPoints[i+1L, ]/5) * rotor
}

# Kochanek-Bartels quaternions spline
rotors <- KochanekBartels(
  keyRotors, n_intertimes = 25L, endcondition = "closed", tcb = c(-1, 5, 0)
)

# construction of the interpolating points on the sphere
points <- matrix(nrow = 0L, ncol = 3L)
keyPoint1 <- rbind(keyPoints[1L, ])
for(i in seq_along(rotors)){
  points <- rbind(points, rotate(keyPoint1, rotors[i]))
}

# visualize the result with the 'rgl' package
library(rgl)
spheres3d(0, 0, 0, radius = 5, color = "lightgreen")
spheres3d(points, radius = 0.2, color = "midnightblue")
spheres3d(keyPoints, radius = 0.25, color = "red")

# A CONSTANT SPEED EXAMPLE ####
\donttest{
library(onion)
keyPoints <- rbind(
  c(5, 0, 0),
  c(0, 5, 0),
  c(0, 0, 5)
)
n_keyPoints <- nrow(keyPoints)

# construction of the key rotors; the first key rotor is the identity
#   quaternion and rotor i sends the key point i-1 to the key point i
keyRotors <- quaternion(length.out = n_keyPoints)
rotor <- keyRotors[1L] <- H1
for(i in seq_len(n_keyPoints - 1L)){
  keyRotors[i+1L] <- rotor <-
    quaternionFromTo(keyPoints[i, ]/5, keyPoints[i+1L, ]/5) * rotor
}

# Kochanek-Bartels quaternions spline with constant speed
spline <- KochanekBartels(
  keyRotors, endcondition = "closed", constantSpeed = TRUE, tcb = c(-2, 1, 0)
)
times <- interpolateTimes(attr(spline, "times"), n = 10L)
rotors1 <- spline(head(times, -1L)) # this step takes a while

# construction of the interpolating points on the sphere
points1 <- matrix(nrow = 0L, ncol = 3L)
keyPoint1 <- rbind(keyPoints[1L, ])
for(i in seq_along(rotors1)){
  points1 <- rbind(points1, rotate(keyPoint1, rotors1[i]))
}

# Comparison with the non-constant speed Kochanek-Bartels quaternions spline
rotors2 <- KochanekBartels(
  keyRotors, n_intertimes = 10L, endcondition = "closed", tcb = c(-2, 1, 0)
)
points2 <- matrix(nrow = 0L, ncol = 3L)
for(i in seq_along(rotors2)){
  points2 <- rbind(points2, rotate(keyPoint1, rotors2[i]))
}

# visualize the results with the 'rgl' package
library(rgl)
spheres3d(0, 0, 0, radius = 5, color = "lightgreen")
spheres3d(keyPoints, radius = 0.25, color = "red")
spheres3d(points1, radius = 0.2, color = "midnightblue")
spheres3d(points2, radius = 0.2, color = "yellow")

# compare on an animation:
ico <- icosahedron3d()
ico$material <- list(colors = hcl.colors(20, palette = "viridis"))
ico$meshColor <- "faces"
open3d() # constant speed camera rotation
for(i in 1L:length(rotors1)){
  par3d(userMatrix = rotationMatrix(matrix = as.orthogonal(rotors1[i])))
  shade3d(ico)
  Sys.sleep(0.5)
  clear3d()
}
close3d()
open3d() # non-constant speed camera rotation
for(i in 1L:length(rotors2)){
  par3d(userMatrix = rotationMatrix(matrix = as.orthogonal(rotors2[i])))
  shade3d(ico)
  Sys.sleep(0.5)
  clear3d()
}
}
}
\references{
Doris H. U. Kochanek and Richard H. Bartels.
  \emph{Interpolating splines with local tension, continuity,
  and bias control.}.
  11th Annual Conference on Computer Graphics and Interactive Techniques,
  33–41, 1984.
  <doi:10.1145/800031.808575>
}
\author{
Stéphane Laurent. Original Python code by Matthias Geier.
}
